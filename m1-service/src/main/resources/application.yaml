# application.yml — це базовий (default) файл конфігурації, який Spring Boot завжди завантажує першим.
# Усі інші профілі (application-docker.yml, application-prod.yml) — розширюють або перевизначають його.
# Залишай application.yml максимально чистим — лише спільні речі.

# -----
# spring: { cloud: { discovery: { client: { enabled: true } } } }
# eureka: { client: { service-url: { defaultZone: http://cs_eureka_server:8761/eureka } } }
# logging.level.root: INFO #для вісх пакетів, для яких нижче НЕ задано рівень
# -----

#logging:
#  level:
#    root: INFO
#    org.springframework.cloud.config.client.ConfigServerConfigDataLoader: WARN
#  pattern:
#    console: "%d{d-MMM-yyyy HH:mm:ss.SSS}ms1 [%thread] [%-5level | %logger{1}]@> %msg%n"
# %location, %method, %line, %file, @caller - very expensive!
# %mdc{requestId} - analog for %X in log4j

management:
  health:
    kubernetes:
      enabled: false # minikube is slow, this will avoid using Fabric8HealthIndicator each time I check a health
    consulHealthCheck: # name of my custom healthIndicator bean (custom healthcheck)
      enabled: false
  tracing:
    enabled: true
    sampling:
      probability: 1.0 # % of requests to be traced (0.0 - 1.0)
  zipkin:
    enabled: false
  simple:
    metrics:
      export:
        enabled: true
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    #    loggers:
    #      access: ALL # WAS -> enabled: true # (for '/actuator/loggers/{}' only)
    #    metrics:
    #      access: ALL # was -> enabled: true
    health:
      show-details: always

springdoc:
  swagger-ui:
    enabled: true
    # http://host:port/swagger-ui/index.html (append '?urls.primaryName=m1doc' for specific controller)
  api-docs:
    enabled: true
    # http://host:port/v3/api-docs (append '.yaml' to download) - All controllers in the project
  group-configs:
    - group: m1doc
      paths-to-match:
        - /api/m1doc/**
    # http://host:port/v3/api-docs/m1doc - only for controller/s specified in 'paths-to-match'
    # the 'paths-to-match' should match with @RequestMapping on specific controller

spring:
  application:
    name: m1-service
  config:
    import:
      - "kubernetes:"
      - "optional:consul:"
      - "optional:vault:"
  cloud:
    kubernetes:
      # 1) By default, enableApi=false:
      # Spring Cloud Kubernetes expects ConfigMap/Secret to me mounted as volume into container (/config OR /secrets).
      # For enableApi=true: it searches for ConfigMap/Secret in specified namespace by the following order-priority:
      # -> application, application-${profile}, ${spring.application.name}, ${spring.application.name}-${profile}
      # The last one overlaps the previous one (if any matches found).
      # 2) SpringCloudK8s does not require explicit URI.
      # It uses KUBERNETES_SERVICE_HOST:KUBERNETES_SERVICE_PORT that K8s automatically adds to POD env (10.96.0.1:443).
      enabled: true
      config:
        enabled: true
        enableApi: true
        namespace: sample-mcs
        include-profile-specific-sources: false
      secrets:
        enabled: true
        enableApi: true
        namespace: sample-mcs
      discovery:
        enabled: false # disable (requires rbac+access in k8s)
        all-namespaces: false
        namespace: sample-mcs
      reload:
        enabled: true
        mode: event # [ event, polling (uses 'period=60s') ]
        strategy: refresh
    consul:
      enabled: false # disable if not use
      host: ${SPRING_CLOUD_CONSUL_HOST}
      port: ${SPRING_CLOUD_CONSUL_PORT}
      config:
        format: YAML
        enabled: false # disable if not use
        fail-fast: true
        default-context: application
      discovery:
        enabled: true
        register: true
        prefer-ip-address: false
        health-check-interval: 5s
        # catalog-services-watch-delay: 1000
        health-check-path: /actuator/health
        # health-check-url: http://m1service:8080/actuator/health
        instance-id: ${spring.application.name}-${HOSTNAME} # to distinguish different service-instances in Consul
    vault:
      enabled: false
      fail-fast: true
      uri: http://${SPRING_CLOUD_VAULT_HOST}:8200
      token: ${SPRING_CLOUD_VAULT_TOKEN} # authentication (for DEV only)
      kv:
        enabled: false # disable if not use
        backend: secret
        profile-separator: /
        default-context: application


# http://localhost:8081/actuator/metrics/resilience4j.circuitbreaker.slow.calls?tag=name:circuitBreakerForM2ServiceCall
# http://localhost:8081/actuator/metrics/resilience4j.circuitbreaker.calls?tag=name:circuitBreakerForM2ServiceCall
# https://resilience4j.readme.io/docs/circuitbreaker
resilience4j:
  circuitbreaker:
    instances:
      circuitBreakerForM2ServiceCall:
        failureRateThreshold: 50 # percentage of failed calls (def=50%)
        slowCallRateThreshold: 25 # percentage of slow calls (def=100%)
        slowCallDurationThreshold: 2s # calls taking longer than this duration are considered slow (def=60s)
        permittedNumberOfCallsInHalfOpenState: 2 # number of permitted calls when CB is in the HALF_OPEN state (def=10)
        maxWaitDurationInHalfOpenState: 0 # max time the CB is allowed to remain in HALF_OPEN state before it is automatically forced back into the OPEN state (def=0 - unlimited)
        slidingWindowType: COUNT_BASED # type of sliding window used to record call outcomes: COUNT_BASED, TIME_BASED (def=COUNT_BASED)
        slidingWindowSize: 100 # size of sliding window. If COUNT_BASED, it is number of calls. If TIME_BASED, it is duration in seconds (def=100)
        minimumNumberOfCalls: 4 # minimum number of calls required in sliding window before the failure rate is calculated (def=100)
        waitDurationInOpenState: 30s # time the CB waits in the OPEN state before transitioning to HALF_OPEN (def=60s)
        automaticTransitionFromOpenToHalfOpenEnabled: true # whether the CB automatically transitions from OPEN to HALF_OPEN after waitDurationInOpenState (def=false)
        # The size of a circular buffer that stores the latest circuit breaker events.
        # These stored events can be viewed via Actuator endpoint '/actuator/circuitbreakerevents'.
        eventConsumerBufferSize: 10 # by default, it keeps only the most recent 10 events (def=10)
        registerHealthIndicator: true # integrates the CB's state into Spring Boot Actuator's endpoint: /actuator/health
        # recordExceptions: List of exception types that should be recorded as failures. Default: (all codes except 2xx/3xx)
        # ignoreExceptions: List of exception types that should be ignored and not count as failures. Default: Empty list
        # recordFailurePredicate: Custom predicate to determine if a call should be recorded as a failure. Default: Records all exceptions as failures.
        # ignoreExceptionPredicate: Custom predicate to determine if an exception should be ignored. Default: Ignores no exceptions.

  timelimiter: # limits the method execution time
    instances:
      circuitBreakerForM2ServiceCall:
        timeoutDuration: 4s # обмежує час виконання самого зовнішнього виклику (def=1s)
        cancelRunningFuture: true
        eventConsumerBufferSize: 10
        registerHealthIndicator: true

  ratelimiter: # limits the number of calls allowed during a certain period of time
    instances:
      circuitBreakerForM2ServiceCall:
        limitForPeriod: 5 # max number of requests allowed during 'limitRefreshPeriod'
        limitRefreshPeriod: 10s # given period of time
        timeoutDuration: 0ms # обмежує час очікування дозволу на виконання запиту (0 - recommended for react)

  retry: # repeats execution in case of method failure
    instances:
      circuitBreakerForM2ServiceCall:
        maxAttempts: 3 # attempts (example: if set to 5, it means -> 1 original + 4 retries)
        waitDuration: 2s # waiting time between attempts
        maxDuration: 30s # optional: overall waiting time for all attempts (additional config over maxAttempts+waitDuration)
        # retryExceptions: # optional: list of exception types that should be indicated for retry

  bulkhead: # controls number of parallel requests
    instances:
      circuitBreakerForM2ServiceCall:
        maxConcurrentCalls: 20 # max number of parallel method call
        maxWaitDuration: 100ms # how long to wait for free slot, when reached the maxConcurrentCalls
  # ----------------------------------------------------------------------------------------------------------------------
  # Difference between 'resilience4j.circuitbreaker.slowCallDurationThreshold' і 'timelimiter.timeoutDuration':
  # 1
  # a) Виклик НЕ переривається (він продовжує виконуватися до завершення).
  # b) Для статистики він позначається як "повільний".
  # 2
  # a) Виклик переривається (викидається TimeoutException).
  # b) Для статистики він позначається як "невдалий".